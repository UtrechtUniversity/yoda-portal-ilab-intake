<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

define('UPDATE_SUCCESS', 0);
define('DELETE_FAILED', - 1);
define('ADD_FAILED', -2);
define('UPDATE_FAILED', -3);

class MetadataModel extends CI_Model {

    public function __construct()
    {
        parent::__construct();
    }

    /**
     * This function writes the changes a user made in the metadata edit
     * form to the iRODS object the meta data is associated with
     * @param iRodsAccount      Reference to the rods account object of the
     *                          user
     * @param object            The path to the object the meta data should
     *                          be associated with
     * @param changes           The array of changes as generated by the
     *                          metadata controller update function
     * @return array            Array indicating success for the actions
     *                          remove, add and update
     */
    public function processResults($iRodsAccount, $object, $changes) {
        $removeTemplate = <<<'RULE'
    *kverr = errorcode(msiAddKeyVal(%1$s, %2$s, %3$s));
    *rerr = -1;
    if(*kverr == 0) {
        *rerr = errorcode(msiRemoveKeyValuePairsFromObj(%1$s, *objectPath, *t));
    }
    if(*kverr != 0 || *rerr != 0) {
        writeLine("serverLog", "Could not remove '%3$s' from key '%2$s' for *objectPath");
        writeLine("serverLog", "Got error for creating keyval pair *kverr and for removing *rerr");
        *removeFailed = cons(%2$s, *removeFailed);
    }


RULE;

        $addTemplate = <<<'RULE'
    *kverr = errorcode(msiAddKeyVal(%1$s, %2$s, %3$s));
    *aerr = -1;
    if(*kverr == 0) {
        *aerr = errorcode(msiAssociateKeyValuePairsToObj(%1$s, *objectPath, *t));
    }
    if(*kverr != 0 || *aerr != 0) {
        writeLine("serverLog", "Could not add '%3$s' to key '%2$s' for *objectPath");
        writeLine("serverLog", "Got error for creating keyval pair *kverr and for adding *aerr");
        *addFailed = cons(%2$s, *addFailed);
    }


RULE;
        
        // 1) keyValPair to remove
        // 2) key for key val pair to update
        // 3) value to remove from key
        // 4) keyValPair to add
        // 5) value to add to key
        $replaceTemplate = <<<'RULE'
    *kverr = errorcode(msiAddKeyVal(%1$s, %2$s, %3$s));
    *urerr = -1;
    *uaerr = -1; 
    if(*kverr == 0) {
        *urerr = errorcode(msiRemoveKeyValuePairsFromObj(%1$s, *objectPath, *t));
        if(*urerr == 0) {
            *kverr = errorcode(msiAddKeyVal(%4$s, %2$s, %5$s));
            if(*kverr == 0) {
                *uaerr = errorcode(msiAssociateKeyValuePairsToObj(%4$s, *objectPath, *t));
            }
        }
    }
    if(*urerr != 0 || *uaerr != 0) {
        writeLine("serverLog", "Could not update from '%3$s' to '%5$s' on '%2$s' for *objectPath");
        writeLine("serverLog", "Got error removing *urerr and adding *uaerr");
        *updateFailed = cons(%2$s, *updateFailed);
    }


RULE;
        $params = array("*objectPath" => $object);
        $ruleBody = <<<RULE
myRule {
    *removeFailed = list();
    *addFailed = list();
    *updateFailed = list();
    msiGetObjType(*objectPath, *t);


RULE;
        $a = 0;
        $d = 0;
        $k = 0;
        $kv = 0;
        $prfx = $this->metadatafields->getPrefix($object);
        foreach($changes as $key => $valueList) {
            $kvar = "*key" . $k;
            $params[$kvar] = $prfx . $key;
            $k++;
            foreach($valueList as $values) {
                if($values->delete && $values->add) {
                    $dv = "*delVal" . $d;
                    $params[$dv] = $values->delete;
                    $d++;
                    $av = "*addVal" . $a;
                    $params[$av] = $values->add;
                    $a++;
                    $kv1 = "*kv" . $kv;
                    $kv++;
                    $kv2 = "*kv" . $kv;
                    $kv++;

                    $ruleBody .= sprintf($replaceTemplate, $kv1, $kvar, $dv, $kv2, $av);
                } else if($values->delete) {
                    $dv = "*delVal" . $d;
                    $params[$dv] = $values->delete;
                    $d++;
                    $kv1 = "*kv" . $kv;
                    $kv++;

                    $ruleBody .= sprintf($removeTemplate, $kv1, $kvar, $dv);                    
                } else {
                    $av = "*addVal" . $a;
                    $params[$av] = $values->add;
                    $a++;
                    $kv1 = "*kv" . $kv;
                    $kv++;

                    $ruleBody .= sprintf($addTemplate, $kv1, $kvar, $av);
                }
            }
        }

        $ruleBody .= <<<'RULE'

    uuJoin(",", *addFailed, *addErrors);
    uuJoin(",", *removeFailed, *removeErrors);
    uuJoin(",", *updateFailed, *updateErrors);
}
RULE;
        // echo sprintf('<pre>%s</pre>', $ruleBody);
        // var_dump($params);

        try {
            $rule = new ProdsRule(
                $iRodsAccount,
                $ruleBody,
                $params,
                array(
                    "*addErrors", "*removeErrors", "*updateErrors"
                )
            );

            $result = $rule->execute();

            $deleteErrors = explode(",", $result["*removeErrors"]);
            $addErrors = explode(",", $result["*addErrors"]);
            $updateErrors = explode(",", $result["*updateErrors"]);

            $status = array(
                "success" => ($this->isEmpty($deleteErrors) && $this->isEmpty($addErrors) && $this->isEmpty($updateErrors)),
                "delete" => $this->isEmpty($deleteErrors) ? false : $deleteErrors,
                "add" => $this->isEmpty($addErrors) ? false : $deleteErrors,
                "update" => $this->isEmpty($updateErrors) ? false : $updateErrors
            );

            return $status;

        } catch(RODSException $e) {
            echo $e->showStacktrace();
            return UPDATE_FAILED;
        }

        return UPDATE_FAILED;
    }

    /**
     * Tiny helper function that checks if a value is empty or not
     * @param val       The value to check
     * @return bool     Boolean, true iff val is empty
     */
    private function isEmpty($val) {
        if(is_array($val)) return !$val || sizeof($val) === 0 || sizeof($val) === 1 && $val[0] === "";
        else if (is_string($val)) return $val === "";
        else return $val === null;
    }

    /**
     * Function that queries iRODS for all metadata on an object and filters them
     * so only the key value pairs from which the keys are passed to this fucntion
     * are kept.
     * 
     * @param rodsaccount       Reference to the rods account object of the user
     * @param keyList           List of keys that should be kept during filtering
     * @param object            The object path the meta data should be retreived 
     *                          from
     */
    public function getValuesForKeys($rodsaccount, $keyList, $object) {
        $prefixedKeyList = array();
        foreach($keyList as $key) {
            $prefixedKeyList[$this->metadatafields->prefixKey($key, $object)] = $key;
        }

        try {
            $prodsdir = new ProdsDir($rodsaccount, $object);
            $metadatas = $prodsdir->getMeta();

            $rodsKVPairs = array();
            foreach($metadatas as $key => $val) {
                if(array_key_exists($val->name, $rodsKVPairs)) {
                    $rodsKVPairs[$val->name][] = htmlentities($val->value);
                } else {
                    $rodsKVPairs[$val->name] = array(htmlentities($val->value));
                }
            }

            $keyValuePairs = array();
            foreach($prefixedKeyList as $prefixed_key => $key) {
                $keyValuePairs[$key] = array_key_exists($prefixed_key, $rodsKVPairs) ? $rodsKVPairs[$prefixed_key] : array();
            }   

            return $keyValuePairs;

        } catch(RODSException $e) {
            echo $e->showStacktrace();
            return false;
        }
    }

    /**
     * Method that queries irods for metadata values for a given key that match
     * a given search string
     *
     * @param iRodsAccount      Reference to the rods account object of the user
     * @param key               The metadata key to extract possible values from
     * @param searchString      A searchstring to refine the values that are found by
     * @return array            Containing all previously used values for the given
     *                          key that match the given search string
     */
    public static function getMetadataForKeyLike($iRodsAccount, $key, $searchString) {
        $ruleBody = '
        myRule {
            *isCollection = true;
            uuIiGetAvailableValuesForKeyLike(*key, *searchString, *isCollection, *values);
            uuJoin("#;#", *values, *str);
        }';

        try {
            $rule = new ProdsRule(
                $iRodsAccount,
                $ruleBody,
                array(
                    "*key" => $key,
                    "*searchString" => $searchString
                    ),
                array("*str")
            );

            $result = $rule->execute();

            if($result && array_key_exists("*str", $result)) {
                $like = explode("#;#", $result["*str"]);
                return array_slice($like, 1);
            }

        } catch(RODSException $e) {
            return false;
        }
        return false;
    }


}